* dwim-shell-command

[[file:images/template.png]]

** Run M-x =dwim-shell-command= to execute [[https://en.wikipedia.org/wiki/DWIM][DWIM]] shell commands
- Asynchronously.
- Using noweb templates.
- Automatically injecting files (from [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] or other buffers) or kill ring.
- Managing buffer focus with heuristics.
- Showing progress bar.
- Quick buffer exit.
- More reusable history.

** Bring command-line utilities to your Emacs workflows

Use =dwim-shell-command-on-marked-files= to easily integrate command-line utilities into frequent Emacs workflows (ie. operate on current buffer or [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] files).

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-command-convert-to-gif ()
    "Convert all marked videos to optimized gif(s)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Convert to gif"
     "ffmpeg -loglevel quiet -stats -y -i <<f>> -pix_fmt rgb24 -r 15 <<fne>>.gif"
     :utils "ffmpeg"))
#+end_src

* Which files

=dwim-shell-command= attempts to guess which file(s) you may want the command to operate on.

If visiting a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] buffer, draw the marked file(s).

[[file:images/diredmark.gif]]

If visiting any other buffer with an associated file, use that.

#+ATTR_html: :width 400px
[[file:images/blur.png]]

* noweb templates

Operate on drawn files using either the following:

  - =<<f>>= (file path)
  - =<<fne>>= (file path without extension)
  - =<<e>>= (extension)
  - =<<td>>= (generate a temporary directory)
  - =<<*>>= (all files joined)
  - =<<cb>>= (clipboard)

For example:

With drawn files =path/to/image1.png= and =path/to/image2.png=

  =convert <<f>> <<fne>>.jpg= expands to

  #+begin_src sh
    convert path/to/image1.png path/to/image1.jpg
    convert path/to/image2.png path/to/image2.jpg
  #+end_src

  while =ls -lh <<*>>= expands to

  #+begin_src sh
    ls -lh path/to/image1.png path/to/image2.png
  #+end_src

* Focus

=dwim-shell-command= creates a process buffer to capture command output, but neither displays nor focuses on it by default. Instead, it tries to guess what's more convenient to focus on.

While the process is busy, show a spinner in the minibuffer. No focus changes.

[[file:images/progress.gif]]

After process is finished:

If there were any files created in the =default-directory=, jump to a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][dired]] buffer and move point to the new file (via [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired-Enter.html][dired-jump]]).

[[file:images/showme.png]]


If no new files were created, automatically switch focus to the process buffer and display its output.

[[file:images/apple.gif]]

Note: You can prevent this automatic focus by prepending your command with whitespace.

  " convert <<f>> <<fne>>.jpg"

If the shell command caused any errors, offer to focus the process buffer and display its output.

[[file:images/couldnt.png]]

*** Easily create utilities

Command-line utilities like [[https://ffmpeg.org/][ffmpeg]] can be easily integrated into Emacs flows (without the need to remember any flags or parameters) by wrapping command invocations into functions and invoking via =M-x= (or your favorite binding). Same DWIM behavior from =dwim-shell-command= is inherited.

All gifs in this README were created via M-x =dwim-shell-command-convert-to-gif=, powered by =dwim-shell-command-on-marked-files=:

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-command-convert-to-gif ()
    "Convert all marked videos to optimized gif(s)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Convert to gif"
     "ffmpeg -loglevel quiet -stats -y -i <<f>> -pix_fmt rgb24 -r 15 <<fne>>.gif"
     :utils "ffmpeg"))
#+end_src

[[file:images/togif_x1.5.gif]]

This makes wrapping one-liners a breeze, so let's do some more...

#+begin_src emacs-lisp :lexical no
  (defun dwim-shell-command-convert-audio-to-mp3 ()
    "Convert all marked audio to mp3(s)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Convert to mp3"
     "ffmpeg -stats -n -i '<<f>>' -acodec libmp3lame '<<fne>>.mp3'"
     :utils "ffmpeg"))

  (defun dwim-shell-command-convert-image-to-jpg ()
    "Convert all marked images to jpg(s)."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Convert to jpg"
     "convert -verbose '<<f>>' '<<fne>>.jpg'"
     :utils "convert"))

  (defun dwim-shell-command-drop-video-audio ()
    "Drop audio from all marked videos."
    (interactive)
    (dwim-shell-command-on-marked-files
     "Drop audio" "ffmpeg -i '<<f>>' -c copy -an '<<fne>>_no_audio.<<e>>'"
     :utils "ffmpeg"))
#+end_src

* Quick exit

Process buffers are read-only and can be quickly closed by pressing =q=.
* More reusable history
Because of templates, command history becomes automatically reusable in other contexts.

[[file:images/history.png]]

* Install

Use your preferred way to install /dwim-shell-command/. Until available on [[https://melpa.org/][Melpa]], you'll have to download it from github.

#+begin_src emacs-lisp
  (require 'dwim-shell-command)
#+end_src

Now you're ready to run

M-x =dwim-shell-command=

** use-package

You can load with use-package and remap to =shell-command='s existing binding using something like:

#+begin_src emacs-lisp :lexical no
  (use-package dwim-shell-command
    :bind (([remap shell-command] . dwim-shell-command)
           :map dired-mode-map
           ([remap dired-do-async-shell-command] . dwim-shell-command)
           ([remap dired-do-shell-command] . dwim-shell-command)
           ([remap dired-smart-shell-command] . dwim-shell-command)))
#+end_src
